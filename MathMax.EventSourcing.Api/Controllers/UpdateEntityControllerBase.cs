using System;
using System.Linq.Expressions;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

using MathMax.EventSourcing.Core.Repositories;
using MathMax.EventSourcing.Infrastructure.Repositories;
using MathMax.EventSourcing.Api.Requests;

namespace MathMax.EventSourcing.Api.Controllers;

/// <summary>
/// Abstract base controller for handling entity update operations in an event-sourced system.
/// Provides common functionality for updating entities with proper validation, error handling, 
/// logging, and command processing. Ensures consistency between URL parameters and request data.
/// </summary>
/// <typeparam name="TRequest">The type of the update request DTO that implements IEntityRequest</typeparam>
/// <typeparam name="TCommand">The type of the command object that will be created from the request</typeparam>
/// <typeparam name="TEvent">The type of the event that will be generated by the command handler</typeparam>
[ApiController]
[Produces("application/json")]
public abstract class UpdateEntityControllerBase<TRequest, TCommand, TEvent> : EntityControllerBase<TRequest, TCommand, TEvent>
    where TRequest : class, IUpdateEntityRequest
    where TCommand : class
    where TEvent : class
{
    /// <summary>
    /// Initializes a new instance of the UpdateEntityControllerBase class.
    /// </summary>
    /// <param name="logger">The logger instance for recording operations and errors</param>
    /// <param name="handler">The command handler responsible for processing update commands</param>
    /// <param name="getAggregateIdExpression">Expression to extract the aggregate ID from the request object</param>
    /// <param name="entityName">The human-readable name of the entity type for error messages and logging</param>
    protected UpdateEntityControllerBase(
        ILogger logger,
        ICommandHandler<TCommand, TEvent> handler,
        Expression<Func<TRequest, Guid>> getAggregateIdExpression,
        string entityName
    ) : base(logger, handler, getAggregateIdExpression, entityName)
    {
    }

    /// <summary>
    /// Handles HTTP PUT requests to update an entity in the event-sourced system.
    /// Validates the request, ensures URL ID matches request aggregate ID, creates and executes
    /// the appropriate command, and returns proper HTTP responses with error handling.
    /// </summary>
    /// <param name="id">The unique identifier of the entity from the URL route</param>
    /// <param name="request">The update request containing the entity data and version information</param>
    /// <returns>
    /// - 200 OK with event envelope if successful
    /// - 400 Bad Request if validation fails or URL/request ID mismatch
    /// - 404 Not Found if the entity doesn't exist
    /// - 409 Conflict if there's a version conflict (optimistic concurrency)
    /// - 500 Internal Server Error for unexpected errors
    /// </returns>
    [HttpPut("{id}")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<IActionResult> UpdateEntity(Guid id, [FromBody] TRequest request)
    {
        try
        {
            var validationResult = await ValidateRequestAsync(request, id);
            if (validationResult != null)
            {
                Logger.LogWarning(validationResult);
                return BadRequest(validationResult);
            }

            // Create the command from the request
            var command = CreateCommand(request);

            // Execute the command
            var result = await CommandHandler.HandleAsync(command);

            // Return the appropriate response
            return CreateSuccessResponse(result);
        }
        catch (EntityNotFoundException ex)
        {
            var message = GetNotFoundMessage(request, id);
            Logger.LogWarning(ex, message);
            return NotFound(message);
        }
        catch (EventVersionConflictException ex)
        {
            var message = GetConflictMessage(ex, request, id);
            Logger.LogWarning(ex, message);
            return Conflict(message);
        }
        catch (Exception ex)
        {
            var message = GetServerErrorMessage(ex, request, id);
            Logger.LogError(ex, message);
            return StatusCode(StatusCodes.Status500InternalServerError, message);
        }
    }

    private async Task<string?> ValidateRequestAsync(TRequest request, Guid urlId)
    {
            var aggregateId = GetAggregateId(request);
            
            // Validate that URL ID matches AggregateId ID
            if (urlId != aggregateId)
            {
                return GetUrlIdAndAggregateIdMismatchMessage(request, urlId);
            }

            return await ValidateRequestAsync(request);
    }

    /// <summary>
    /// Validates the update request for business rules and data integrity.
    /// Override this method in derived classes to implement entity-specific validation logic.
    /// This method is called after basic URL/aggregate ID validation has passed.
    /// </summary>
    /// <param name="request">The update request to validate</param>
    /// <returns>
    /// A task that resolves to an error message string if validation fails, 
    /// or null if the request is valid
    /// </returns>
    protected virtual Task<string?> ValidateRequestAsync(TRequest request)
    {
        return Task.FromResult<string?>(null);
    }

    /// <summary>
    /// Creates a command object from the validated update request.
    /// This method must be implemented by derived classes to convert the request DTO
    /// into the appropriate command type for the specific entity being updated.
    /// </summary>
    /// <param name="request">The validated update request containing the entity data</param>
    /// <returns>A command object that can be processed by the command handler</returns>
    protected abstract override TCommand CreateCommand(TRequest request);

    /// <summary>
    /// Creates the HTTP response for a successful update operation.
    /// Override this method in derived classes to customize the success response format
    /// or add additional response headers/data.
    /// </summary>
    /// <param name="eventEnvelope">The event envelope containing the generated event and metadata</param>
    /// <returns>An HTTP 200 OK response with the event envelope in the body</returns>
    protected virtual IActionResult CreateSuccessResponse(EventEnvelope<TEvent> eventEnvelope)
    {
        return Ok(eventEnvelope);
    }

    /// <summary>
    /// Generates an error message for version conflict scenarios (HTTP 409 Conflict).
    /// Called when optimistic concurrency control detects that the entity has been
    /// modified by another process since the client retrieved it.
    /// </summary>
    /// <param name="ex">The version conflict exception containing details about the conflict</param>
    /// <param name="request">The update request that caused the conflict</param>
    /// <param name="aggregateId">The ID of the entity that had the version conflict</param>
    /// <returns>A user-friendly error message explaining the version conflict</returns>
    protected override string GetConflictMessage(EventVersionConflictException ex, TRequest request, Guid aggregateId)
    {
        return $"Version conflict: {EntityName} with {AggregateIdPropertyName} {aggregateId} has an already registered version {request.Version}: {ex.Message}";
    }

    /// <summary>
    /// Generates an error message for entity not found scenarios (HTTP 404 Not Found).
    /// Called when the requested entity doesn't exist in the system.
    /// </summary>
    /// <param name="request">The update request for the non-existent entity</param>
    /// <param name="id">The ID of the entity that was not found</param>
    /// <returns>A user-friendly error message indicating the entity was not found</returns>
    protected virtual string GetNotFoundMessage(TRequest request, Guid id)
    {
        return $"{EntityName} with {AggregateIdPropertyName} {id} not found.";
    }

    /// <summary>
    /// Generates an error message for unexpected server errors (HTTP 500 Internal Server Error).
    /// Called when an unhandled exception occurs during the update operation.
    /// </summary>
    /// <param name="ex">The exception that caused the server error</param>
    /// <param name="request">The update request that was being processed when the error occurred</param>
    /// <param name="aggregateId">The ID of the entity being updated when the error occurred</param>
    /// <returns>A user-friendly error message for the server error</returns>
    protected override string GetServerErrorMessage(Exception ex, TRequest request, Guid aggregateId)
    {
        return $"An error occurred while attempting to updating {EntityName} with {AggregateIdPropertyName} {aggregateId}: {ex.Message}";
    }

    /// <summary>
    /// Generates an error message when the URL ID parameter doesn't match the aggregate ID in the request body.
    /// This validation ensures data consistency and prevents accidental updates to the wrong entity.
    /// </summary>
    /// <param name="request">The update request containing the aggregate ID that doesn't match the URL</param>
    /// <param name="id">The ID from the URL that doesn't match the request aggregate ID</param>
    /// <returns>A user-friendly error message explaining the ID mismatch</returns>
    protected virtual string GetUrlIdAndAggregateIdMismatchMessage(TRequest request, Guid id)
    {
        return $"URL {id} does not match request {AggregateIdPropertyName} {GetAggregateId(request)}.";
    }
}
